var documenterSearchIndex = {"docs":
[{"location":"api/#Taproots-API","page":"API","title":"Taproots API","text":"","category":"section"},{"location":"api/#Taproots","page":"API","title":"Taproots","text":"Taproots is a library for traversing nested data structures.\n\n\n\n\n\n","category":"module"},{"location":"api/#Module-Index","page":"API","title":"Module Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Taproots]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Taproots.Taproot","page":"API","title":"Taproots.Taproot","text":"A Taproot is a single node that that can contain other Taproots. It can itself be contained in a parent Taproot. It is not the main point of this package, but provides a convenience to persist structure when doing maps or other transformations. It is also useful if you simply wish to build a data structure which obeys everything in Taproots.jl. \n\nYou can construct a Taproot either by: \n\nTaproot(data, children) where data is anything that you'd like to store in this node, and children is an iterable list of children \nTaproot(node) where node is some value that has Taproots.children and Taproots.data defined on it. This will recurvisely sink your object into a Taproot\n\n\n\n\n\n","category":"type"},{"location":"api/#Taproots.adjacencymatrix-Tuple{Any}","page":"API","title":"Taproots.adjacencymatrix","text":"adjacencymatrix(taproot)\n\nReturns an adjacency matrix for this taproot and all its children. If two nodes are equivalent they will only appear once here.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.bloom-Tuple{IO, Any}","page":"API","title":"Taproots.bloom","text":"bloom(io::IO, taproot)\n\nPretty print a taproot. Requires you to have used @sprout YourType for it to work.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.bottomup-Tuple{Any}","page":"API","title":"Taproots.bottomup","text":"bottomup(x)\n\nThis creates an eager iterator as a bottomup (reverse level-order) breadth-first search of your custom Taproot. The bottom children are iterated first, and then the next layer up and so on. Leaves are not technically guaranteed to be iterated on first, before parents.  While the other iterators are lazy, this one is eager, and will actually return a vector. \n\nUsage\n\nfor x in bottomup(x)     print(x) end \n\nbottomup(x) <: Vector collect(bottomup(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branches-Tuple{Any}","page":"API","title":"Taproots.branches","text":"branches(x)\n\nThis creates a lazy iterator for the branches (those nodes which have children) of your custom Taproot.\n\nUsage\n\nfor x in branches(x)     print(x) end \n\ncollect(branches(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branchmap!-Tuple{Function, Any}","page":"API","title":"Taproots.branchmap!","text":"branchmap!(f::Function, taproot)\n\nModify the branches of a taproot in place without destroying links to children.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branchmap-Tuple{Function, Any}","page":"API","title":"Taproots.branchmap","text":"branchmap(f::Function, taproot)\n\nDeepcopy a taproot and then modify its branches in place without destroying links to children.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branchprune!-Tuple{Function, Any}","page":"API","title":"Taproots.branchprune!","text":"branchprune!(f::Function, taproot)\n\nThis removes any leaves of the taproot who do not satisfy the criteria given by f in place. f evaluating to true will keep that leaf. This is similar to filter.  However, you cannot prune the root of a taproot. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branchprune-Tuple{Function, Any}","page":"API","title":"Taproots.branchprune","text":"prune(f::Function, taproot)\n\nThis deepcopies the taproot and then removes any leaves who do not satisfy the criteria given by f in place. f evaluating to true will keep that leaf. This is similar to filter.  However, you cannot prune the root of a taproot. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.children-Tuple{Any}","page":"API","title":"Taproots.children","text":"children(x)\n\nGets the children nodes in a Taproot DAG (if defined) of x. This function is meant to be overridden to access Taproot functionality on your own types. \n\nBy default, children(x) will return an empty array, meaning Taproot considers x to be a graph with a singular node (unless you overload this function.) \n\nOverriding this function\n\nSimply define Taproots.children(x::MyType) = ...  Where the ... returns a vector of the things you want to traverse.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.data-Tuple{Any}","page":"API","title":"Taproots.data","text":"data(x)\n\nGets the data of a single node in a Taproot DAG (if defined) of x. This function is meant to be overridden to access Taproot functionality on your own types. \n\nBy default, data(x) will return x, meaning Taproots considers x to be perfectly valid data.\n\nOverriding this function\n\nSimply define Taproots.data(x::MyType) = ...  Where the ... returns whatever data is not already included in the Taproots.children function. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.eachfield-Tuple{Any}","page":"API","title":"Taproots.eachfield","text":"eachfield(x)\n\nReturns a tuple of the values in each field in a struct. Nice for if you have a known number of children. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.findtrace-Tuple{Function, Any}","page":"API","title":"Taproots.findtrace","text":"findtrace(f, parent)\n\nThis is a slower (~linear) algorithm to find the first value where f returns true. It returns a vector which can be used to index into a nested data struct. You can index into your nested data structure using followtrace.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.findtraces-Tuple{Function, Any}","page":"API","title":"Taproots.findtraces","text":"findtraces(f, parent)\n\nThis is a slower (~linear) algorithm to find all values where f returns true. It returns a vector which can be used to index into a nested data struct. You can index into your nested data structure using followtrace.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.followindexes","page":"API","title":"Taproots.followindexes","text":"followindexes(indexable_struct, trace, default_value)\n\nThis is just a convenience function to index into a nest object (potentially not a taproot in any way) by some iterable value of keys. \n\nExample\n\ndict = Dict(1 => Dict(:a => Dict(1 => Dict(:a => \"Finally here\"))))\n\nfollowindexes(dict, (1,:a,1,:a)) == \"Finally here\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Taproots.followtrace-Tuple{Any, Any}","page":"API","title":"Taproots.followtrace","text":"followtrace(parent, trace)\n\nThis is a faster algorithm to get the node which matches a trace. A trace is simply an iterable set of indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.isbranch-Tuple{Any}","page":"API","title":"Taproots.isbranch","text":"isbranch(node)::Bool\n\nTells you whether this node is a branch node (i.e. it has children).\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.ischild-Tuple{Any, Any}","page":"API","title":"Taproots.ischild","text":"ischild(potential_child, parent)::Bool\n\nTells you whether potential_child is a child of parent. This function acts recursively and is not the same as doing potential_child ∈ children(parent).  Time complexity of this is ~linear in the number of edges in your DAG underneath the parent, so use with care for large DAGs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.isleaf-Tuple{Any}","page":"API","title":"Taproots.isleaf","text":"isleaf(node)::Bool\n\nTells you whether this node is a leaf node (i.e. it has no children).\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.isparent-Tuple{Any, Any}","page":"API","title":"Taproots.isparent","text":"isparent(potential_parent, child)::Bool\n\nTells you whether potential_parent is a parent of child. This function acts recursively.  Time complexity of this is ~linear in the number of edges in your DAG underneath the potential_parent, so use with care for large DAGs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leafmap!-Tuple{Function, Any}","page":"API","title":"Taproots.leafmap!","text":"leafmap!(f::Function, taproot)\n\nModify the leaves of a taproot in place. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leafmap-Tuple{Function, Any}","page":"API","title":"Taproots.leafmap","text":"leafmap(f::Function, taproot)\n\nDeepcopy a taproot and then modify its leaves in place. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leafprune!-Tuple{Function, Any}","page":"API","title":"Taproots.leafprune!","text":"leafprune!(f::Function, taproot)\n\nThis removes any leaves of the taproot who do not satisfy the criteria given by f in place. f evaluating to true will keep that leaf. This is similar to filter.  However, you cannot prune the root of a taproot. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leafprune-Tuple{Function, Any}","page":"API","title":"Taproots.leafprune","text":"prune(f::Function, taproot)\n\nThis deepcopies the taproot and then removes any leaves who do not satisfy the criteria given by f in place. f evaluating to true will keep that leaf. This is similar to filter.  However, you cannot prune the root of a taproot. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leaves-Tuple{Any}","page":"API","title":"Taproots.leaves","text":"leaves(x)\n\nThis creates a lazy iterator for the leaves (those nodes which have no children) of your custom Taproot.\n\nUsage\n\nfor x in leaves(x)     print(x) end \n\ncollect(leaves(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.postorder-Tuple{Any}","page":"API","title":"Taproots.postorder","text":"postorder(x)\n\nThis creates a lazy iterator as a postorder depth-first search of your custom Taproot. This is topological order and most of the time, you're looking for this.  In this iterator, children are always iterated on before their parents. Parents will immediately follow their children (so some (possibly irrelevant) children may not be iterated before the parent above them).\n\nUsage\n\nfor x in postorder(x)     print(x) end \n\ncollect(postorder(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.preorder-Tuple{Any}","page":"API","title":"Taproots.preorder","text":"preorder(x)\n\nThis creates a lazy iterator as a preorder depth-first search of your custom Taproot. In this iterator, parents are always iterated on before their children.\n\nUsage\n\nfor x in preorder(x)     print(x) end \n\ncollect(preorder(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.prune!-Tuple{Function, Any}","page":"API","title":"Taproots.prune!","text":"prune!(f::Function, taproot)\n\nThis removes any children who do not satisfy the criteria given by f in place. f evaluating to true will keep that child. This is similar to filter.  However, you cannot prune the root of a taproot. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.prune-Tuple{Function, Any}","page":"API","title":"Taproots.prune","text":"prune(f::Function, taproot)\n\nThis deepcopies the taproot and then removes any children who do not satisfy the criteria given by f in place. f evaluating to true will keep that child. This is similar to filter.  However, you cannot prune the root of a taproot. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.setchildren!-Tuple{Any, Vector}","page":"API","title":"Taproots.setchildren!","text":"setchildren!(node, children::Vector)\n\nSets the children of your node. Useful if you want to be able to prune! your taproot!  Should return the entire node once completed. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.setdata!-Tuple{Any, Any}","page":"API","title":"Taproots.setdata!","text":"setdata!(node, data)\n\nSets the data of your node. Useful if you want to be able to tapmap! your taproot without messing up your children. It should be the case that the following does nothing.  setdata!(origvalue, data(origvalue)) It MUST return the entire node once done (and is allowed to simply return data without modifying the node in place).\n\nExample\n\nTaproots.setdata!(node::MyDataStructure, data) = (node.data = data; node)\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapin-Tuple{Any}","page":"API","title":"Taproots.tapin","text":"tapin(node)\n\nAnother way to access the recursive Taproot constructor, using a custom sink to collect data and children. Requires Taproots.data and Taproots.children to work. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapmap!-Tuple{Function, Any}","page":"API","title":"Taproots.tapmap!","text":"tapmap!(f::Function, taproot)\n\nModify all the data of every node in a taproot in place. f only acts on the data in each node.  This can handle mutable and immutable trees. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapmap-Tuple{Function, Any}","page":"API","title":"Taproots.tapmap","text":"tapmap(f::Function, taproot)\n\nDeepcopy a taproot and then modify its nodes in place. f only acts on the data in each node.  This can handle mutable and immutable trees. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapmapif!-Tuple{Function, Function, Any}","page":"API","title":"Taproots.tapmapif!","text":"tapmapif!(condition::Function, f::Function, taproot)\n\nModifies nodes in place if the entire node satisfies condition. f only acts on the data in each node.  This can handle mutable and immutable trees. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapmapif-Tuple{Function, Function, Any}","page":"API","title":"Taproots.tapmapif","text":"tapmapif(condition::Function, f::Function, taproot)\n\nDeepcopy a taproot and then modify its nodes in place if they satisfy condition. f only acts on the data in each node.  This can handle mutable and immutable trees. \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapout-Tuple{Function, Taproot}","page":"API","title":"Taproots.tapout","text":"tapout(sink::Function, taproot::Taproot)\n\nThis allows you to transform a Taproots.Taproot struct back into one of your own structs. The sink function needs to be able to transform a single node of a Taproot into a node in your struct.  The sink follows the following structure:     sink(data, children) which returns whatever type you want.\n\nAs a simple example, let's say we have\n\nstruct YourType      printablename::String     id::UUID     data     children::Vector{YourType} end Taproots.children(x::YourType) = x.children Taproots.data(x::YourType) = (x.printablename, x.id, x.data)\n\nThen you can convert that to a Taproots.taproot as follows:\n\nyourtype = ...  yourtaproot = tapin(yourtype) yourmodifiedtype = tapout((data, children) -> YourType(data.printablename, data.id, data.data, children), modified_taproot)\n\nIn case you have multiple types in your struct chain, you can say:\n\nfunction sink(data, children)     if data isa String          return data      else          return YourType(data.printable_name, data.id, data.data, children)     end end \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.topdown-Tuple{Any}","page":"API","title":"Taproots.topdown","text":"topdown(x)\n\nThis creates a lazy iterator as a topdown (level-order) breadth-first search of your custom Taproot. The top parents are iterated first, and then the next level down, and so on. All parents are guaranteed to be iterated on before the leaves.\n\nUsage\n\nfor x in topdown(x)     print(x) end \n\ncollect(topdown(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tracepairs-Tuple{Any}","page":"API","title":"Taproots.tracepairs","text":"tracepairs(x)\n\nThis creates a lazy iterator for all the traces and nodes of a taproot.  This will always be in the preorder (depth-first search).\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.traces-Tuple{Any}","page":"API","title":"Taproots.traces","text":"traces(x)\n\nThis creates a lazy iterator for all the traces (vectors of indices) needed to get from the root to one of the children.  This will always be in the preorder (depth-first search). \n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.@sprout-Tuple{Any}","page":"API","title":"Taproots.@sprout","text":"@sprout YourType\n\nThis just sets AbstractTrees.children(x::YourType) = Taproots.children(x::YourType). Must be used before you can bloom or @bloom. \n\n\n\n\n\n","category":"macro"},{"location":"#Taproots.jl","page":"Index","title":"Taproots.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This library helps you traverse your own nested structs and data in easy peasy ways!  This library is inspired by AbstractTrees.jl. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"For the purposes of this package, we'll consider any struct a taproot if:","category":"page"},{"location":"","page":"Index","title":"Index","text":"It has nested data which can be accessed from the struct in some way (whether by using keys or by actually holding that data)\nThat nested data forms a Directed Acyclic Graph (DAG) (warning, this package can't handle cycles – you'll get stackoverflow)\n\"Distance\" between nodes is not something we need to consider (unless it can be held in data of some kind).","category":"page"},{"location":"","page":"Index","title":"Index","text":"That's right, no need to use some struct I created. You can use your own and traverse it a bunch of ways. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Worth a quick note that a Taproot is not quite as general as a DAG – with the main difference being that a Taproot has only one root node, and all other nodes eventually point inwards to that root node. Obviously DAGs can also have a distance between nodes – but we're not interested in that. We're only interested to see if a node can or cannot be reached by another one. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"That being said, many structures in the world form Taproots:","category":"page"},{"location":"","page":"Index","title":"Index","text":"File and folder structures (pls ignore symlinks)\nNested data structures such as JSON, YAML, and so on. Nested Julia Dicts also do this\nA response variable with all its causally-related covariates. ","category":"page"},{"location":"#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"In the julia REPL, type ] and the add Taproots.","category":"page"},{"location":"#How-to-use","page":"Index","title":"How to use","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"You can turn your own structs into Taproots very quickly!","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Taproots\n\nmutable struct MyType \n\tsome_data\n\tchildren\nend\n\nTaproots.children(x::MyType) = x.children ","category":"page"},{"location":"","page":"Index","title":"Index","text":"We're done! You now have access to (almost) all the functionality in Taproots.jl. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Now let's say you create some nastily nested structure: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"my_data = MyType(\"The Root\", [\n\tMyType(\"Some other data\", []),\n\tMyType(\"I can nest data here\", [\n\t\tMyType(\"Such nested, much wow\", [])\n\t]),\n\t\"I don't even need to stick to one type ... but obviously a string has no children\",\n\tDict(\n\t\t:x => \"Taproots.children is already implemented on dicts\",\n\t\t:y => :(\"As well as \" * \" other types\")\n\t)\n])","category":"page"},{"location":"","page":"Index","title":"Index","text":"Now you might wish to traverse ALL that data in a lazy, speedy way:","category":"page"},{"location":"","page":"Index","title":"Index","text":"for nested_data in postorder(my_data)\n\tprintln(nested_data)\nend","category":"page"},{"location":"","page":"Index","title":"Index","text":"Or just the things at the edges (which is what I care about most of the time):","category":"page"},{"location":"","page":"Index","title":"Index","text":"for nested_data in leaves(my_data)\n\tprintln(nested_data)\nend","category":"page"},{"location":"","page":"Index","title":"Index","text":"Similar other options exist as well:","category":"page"},{"location":"","page":"Index","title":"Index","text":"preorder(my_data) # a preorder depth-first search \npostorder(my_data) # this is topological order (or postorder depth-first search)\ntopdown(my_data) # a unique level-order breadth-first search\nbottomup(my_data) # this is just the reverse of topdown. Warning, this one isn't lazy, and it produces a vector to remind you of that. \n\nleaves(my_data) # only look at the data that doesn't have children\nbranches(my_data) # only look at the data that does have children\n\ntraces(my_data) # get all traces (tace = a simple vector of indices in order) so that you can index into a particular child later\ntracepairs(my_data) # get all traces along with values so that you can index into a particular child or just use that information right away","category":"page"},{"location":"","page":"Index","title":"Index","text":"Each of those functions returns a Julia Channel, so you can use it like any iterator, using map, reduce, and Iterators.filter. Obviously you can just collect that into a vector if you prefer (and you don't need the laziness benefits).","category":"page"},{"location":"","page":"Index","title":"Index","text":"my_data_in_a_vec = my_data |> postorder |> collect\nprintln(my_data_in_a_vec)\n\n\nIterators.filter(x -> x isa String, leaves(my_data)) |> first # gives us the only string in the data structure ... \"I don't even need to stick to one type ... but obviously a string has no children\"","category":"page"},{"location":"","page":"Index","title":"Index","text":"Packages like this one are nice but you may be worried about interoperability with other (potentially more expansive) packages. So to make it all work out plainly, you can grab an adjacency matrix of your taproot whenever you want.","category":"page"},{"location":"","page":"Index","title":"Index","text":"adjacencymatrix(my_data) # gives us an adjacency matrix of 1s and 0s","category":"page"},{"location":"","page":"Index","title":"Index","text":"You are now able to shove the structure of your DAG into another graph-specific utility. But don't be too hasty; check out the cool things Taproots.jl can do first!","category":"page"},{"location":"","page":"Index","title":"Index","text":"There are also other handy functions to help you flag certain nodes so you know what they look like in your structure:","category":"page"},{"location":"","page":"Index","title":"Index","text":"ischild(potential_child, parent) # true if the potential child is recursively a child of the parent. This can be slow if your Taproot is big.\nisparent(potential_parent, child) # true if the potential parent is recursively a parent of the child. This can be slow if your Taproot is big.\nisleaf(node) # true if the node has no children\nisbranch(node) # true if the node has any children","category":"page"},{"location":"","page":"Index","title":"Index","text":"There are handy functions to help you find nodes as well! ","category":"page"},{"location":"","page":"Index","title":"Index","text":"findtrace(matcher, my_data) # gets you an index trace of the first node for which matcher(node) evaluates to true. \nfindtrace(child, my_data) # gets you an index trace of the first node which is equal to child. \nfindtraces(matcher, my_data) # gets you every index trace of the nodes for which matcher(node) evaluates to true.\nfindtraces(child, my_data) # gets you every index trace of the nodes for which node == child. \nfollowtrace(my_data, trace) # follows the index down to the pits to get you back whatever is in that index spot","category":"page"},{"location":"#Modification-of-data-and-structure","page":"Index","title":"Modification of data and structure","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Now there comes a time in every Taprootian's life when they yearn to modify their Taproots in place. And this is a dangerous topic because if you modify a Taproot in place, you might destroy the links to the children inadvertently. So for this purpose, you would need to add a few more functions. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Taproots.data(node::MyType) = node.some_data # provide a way to get any auxiliary data (other than children) that your node might contain. Can simply return `node` or nothing at all. Doing this will unlock sinking your type to a Taproots.Taproot. \nTaproots.setdata!(node::MyType, data) = (node.some_data = data; node) # provide a way to set data in your node, if any. It can also do nothing. Once done, it must return `node`. This one as well as the next unlocks `tapmap` and variants.\nTaproots.setchildren!(node::MyType, children::Vector) = (node.children = children; node) # provide a way to set children in your node. Once done, it must return `node`. This one unlocks `prune` and variants. \n````\n\nNow we get the *good* stuff. We can map every node's data while keeping the structure sparkly. \n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia tapmap(x -> x isa String ? uppercase(x) : x, my_data) # x comes straight from Taproots.data(node). Warning! x itself is not a node, and as such the strings inside MyType also get converted. Pretty awesome, but be careful!","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nWe can also get rid of all the nodes we don't like (... except the root, topmost node. Prune won't get rid of that one, and for good reason.)\n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia prune(x -> x isa MyType, my_data) # x is the entire node","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nThere are similar handy functions such as:\n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia tapmap!(f, taprootius) # modify all nodes in place tapmap(f, taprootius) # deepcopy and then modify all nodes in place","category":"page"},{"location":"","page":"Index","title":"Index","text":"tapmapif!(condition, f, taprootius) # modify nodes in place if they satisfy condition. Very handy if your tree has multiple different types.  tapmapif(condition, f, taprootius) # deepcopy and then modify nodes in place if they satisfy condition. Very handy if your tree has multiple different types. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"leafmap!(f, taprootius) # modify all leaves in place leafmap(f, taprootius) # deepcopy and then modify all leaves in place","category":"page"},{"location":"","page":"Index","title":"Index","text":"branchmap!(f, taprootius) # modify all branches in place branchmap(f, taprootius) # deepcopy and then modify all branches in place","category":"page"},{"location":"","page":"Index","title":"Index","text":"prune!(f, taprootius) # get rid of children which do not satisfy f in place prune(f, taprootius) # deepcopy and then get rid of children which do not satisfy f in place","category":"page"},{"location":"","page":"Index","title":"Index","text":"leafprune!(f, taprootius) # get rid of leaves which do not satisfy f in place leafprune(f, taprootius) # deepcopy and then get rid of leaves which do not satisfy f in place","category":"page"},{"location":"","page":"Index","title":"Index","text":"branchprune!(f, taprootius) # get rid of branches which do not satisfy f in place branchprune(f, taprootius) # deepcopy and then get rid of branches which do not satisfy f in place","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nNow from time to time you may not be able to `setdata!` or `setchildren!` because you're dealing with an immutable struct. In that case, just make `setdata!` and `setchildren!` reconstruct your immutable type. \n\n\n## Built-in taproots\n\nIt's not the point of this package, but there is a minimal (but fully functional) mutable struct called Taproot which this package exports. You can use this to store data if you couldn't be bothered with nesting things in your own struct.\nTaproots, however, don't allow arbitrary children types.\n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia Taproot(data::Any, children::Vector{Taproot})","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nAlternatively, you can convert your type to a Taproots.Taproot. \n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia taprootius = tapin(my_data)","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nYou can get back out again simply by providing some kind of sink. \n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia backtothe_future = tapout((data, children) -> MyType(data, children), taprootius)","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nIn the example above, the children will automatically be coverted to `MyType` because the `sink` function we provided gets called recursively. \n\nTaproots.jl also treats many base types like `Dict`, `Vector`, and `Expr` as taproots, and all other types as leaves.\nSo you can do something like this \n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia dict = Dict( \t\t:a => Dict( \t\t\t:b => \"nonsensedata\", \t\t\t:c => \"moredata\", \t\t), \t\t:d => \"final_data\" \t) leafmap!(uppercase, dict)","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nHere's another usecase: metaprogramming. \n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia nums = 1:100 expr = :(append!(map(x -> sqrt(x) == floor(sqrt(x)), nums), map(x -> x^(1/3) == floor(x^(1/3)), nums)) |> unique!) leafmap!(x -> x == :map ? :filter : x, expr) eval(expr)","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nThis last bit here is absolute raw power. Code expressions are abstract syntax trees, and so they are taproots as well.\n\nYou might be wondering at this stage, \"Is every struct actually a taproot\". Of course they are ... \n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia struct FourLeggedStruct  \ta \tb \tc \td end ","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nCan we just define the children to be `(a,b,c,d)`? Yes, we can, and it's easy. But sometimes it's better not to think of them that way, and that's why this isn't the default behaviour of Taproots.jl. But should you want to, you can just do this \n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia Taproots.children(x::FourLeggedStruct) = eachfield(x)","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nOr if you just want to traverse a ton of stuff:\n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia Taproots.children(x) = eachfield(x) # now everything will do this by default (unless more specifically defined). ","category":"page"},{"location":"","page":"Index","title":"Index","text":"\nThere is also one more thing this package does which I think it pretty handy and which is related to the main concepts that Taproot deals with, but does not actually a require a taproot. It requires nested data with keys. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia dict = Dict(1 => Dict(:a => Dict(1 => Dict(:a => \"Finally here\")))) followindexes(dict, (1,:a,1,:a)) == \"Finally here\"","category":"page"},{"location":"","page":"Index","title":"Index","text":"\n\n## Seeing the structure of your DAGs\n\nThis package is interoperable with Term.jl for a CLI view and adds two very nice graph recipes to Plots.jl.  \nThe data inside these can get cluttered, so it's recommended that you just overload `Base.show` for your custom types.\n\n### Terminal visualisation\n","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia @sprout MyType # sets up AbstractTrees.jl and Term.jl so that you can call bloom if you want @bloom my_data # shows the data nicely","category":"page"},{"location":"","page":"Index","title":"Index","text":"\n### Plotting","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia using Plots","category":"page"},{"location":"","page":"Index","title":"Index","text":"plottree(mydata) plotdag(mydata) ```","category":"page"},{"location":"#FAQ","page":"Index","title":"FAQ","text":"","category":"section"},{"location":"#Why-do-I-need-to-define-children-and-data-and-setchildren!-and-setdata!.-Why-not-just-children-and-setchildren!?","page":"Index","title":"Why do I need to define children and data and setchildren! and setdata!. Why not just children and setchildren!?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"So that you don't accidentally lose the children by calling tapmap!, and you don't accidentally modify data with prune!.","category":"page"},{"location":"#Why-is-tapmap-not-as-speedy-as-tapmap!-(and-similar)?","page":"Index","title":"Why is tapmap not as speedy as tapmap! (and similar)?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"tapmap deepcopies before it calls tapmap!. That is expensive, but a neat way of ensuring we don't modify the wrong data. ","category":"page"},{"location":"#How-can-I-improve-the-speed-of-tapmap!-(and-similar)?","page":"Index","title":"How can I improve the speed of tapmap! (and similar)?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Use tapmapif!(condition, f, taproot). This will only execute f and set data and so on if the condition is satisfied. ","category":"page"},{"location":"#What-if-my-struct-is-immutable?","page":"Index","title":"What if my struct is immutable?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"If your Taproots.data is immutable, that's fine. You just need Taproots.setdata! to return the entire node (as always). I catered for that in tapmap! because this is so common with leaf nodes.  tapmap! will automatically reconstruct the children in a nice way for you – but, warning, it calls Taproots.setchildren!.  If your children are immutable, I haven't catered for that nicely, and neither tapmap! nor prune! (and variants) will work. ","category":"page"}]
}
