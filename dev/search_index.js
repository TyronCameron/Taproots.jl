var documenterSearchIndex = {"docs":
[{"location":"api/#Taproots-API","page":"API","title":"Taproots API","text":"","category":"section"},{"location":"api/#Taproots","page":"API","title":"Taproots","text":"Taproots is a library for traversing nested data structures.\n\n\n\n\n\n","category":"module"},{"location":"api/#Module-Index","page":"API","title":"Module Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Taproots]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Taproots.Taproot","page":"API","title":"Taproots.Taproot","text":"A Taproot is a single node that that can contain other Taproots. It can itself be contained in a parent Taproot. It is not the main point of this package, but provides a convenience to persist structure when doing maps or other transformations. It is also useful if you simply wish to build a data structure which already obeys everything in Taproots.jl.\n\nYou can construct a Taproot either by:\n\nTaproot(data, children) where data is anything that you'd like to store in this node, and children is an iterable list of children\nTaproot(node) where node is some value that has Taproots.children and Taproots.data defined on it. This will recurvisely sink your object into a Taproots.Taproot\n\n\n\n\n\n","category":"type"},{"location":"api/#Taproots.adjacencymatrix-Tuple{Any}","page":"API","title":"Taproots.adjacencymatrix","text":"adjacencymatrix(taproot)\n\nReturns an adjacency matrix for this taproot and all its children. If two nodes are equivalent they will only appear once here.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.bloom-Tuple{IO, Any}","page":"API","title":"Taproots.bloom","text":"bloom(io::IO, taproot)\n\nPretty print a taproot. Requires you to have used @sprout YourType for it to work.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.bottomup-Tuple{Any}","page":"API","title":"Taproots.bottomup","text":"bottomup(x)\n\nThis creates an eager iterator as a bottomup (reverse level-order) breadth-first search of your custom Taproot. This is topological order. The bottom children are iterated first, and then the next layer up and so on. Leaves are not technically guaranteed to be iterated on first, before parents. While the other iterators are lazy, this one is eager, and will actually return a vector.\n\nUsage\n\nfor x in bottomup(x)     print(x) end\n\nbottomup(x) <: Vector collect(bottomup(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branches-Tuple{Any}","page":"API","title":"Taproots.branches","text":"branches(x)\n\nThis creates a lazy iterator for the branches (those nodes which have children) of your custom Taproot.\n\nUsage\n\nfor x in branches(x)     print(x) end\n\ncollect(branches(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branchmap!-Tuple{Function, Any}","page":"API","title":"Taproots.branchmap!","text":"branchmap!(f::Function, taproot)\n\nModify the branches of a taproot in place without destroying links to children.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branchmap-Tuple{Function, Any}","page":"API","title":"Taproots.branchmap","text":"branchmap(f::Function, taproot)\n\nDeepcopy a taproot and then modify its branches in place without destroying links to children.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branchprune!-Tuple{Function, Any}","page":"API","title":"Taproots.branchprune!","text":"branchprune!(f::Function, taproot)\n\nThis removes any leaves of the taproot who do not satisfy the criteria given by f in place. f evaluating to true will keep that leaf. This is similar to filter. However, you cannot prune the root of a taproot.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.branchprune-Tuple{Function, Any}","page":"API","title":"Taproots.branchprune","text":"prune(f::Function, taproot)\n\nThis deepcopies the taproot and then removes any leaves who do not satisfy the criteria given by f in place. f evaluating to true will keep that leaf. This is similar to filter. However, you cannot prune the root of a taproot.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.children-Tuple{Any}","page":"API","title":"Taproots.children","text":"children(node)\n\nGets the children nodes in a Taproot DAG (if defined) of node. This function is meant to be overridden to access Taproot.jl functionality on your own types.\n\nBy default, children(node) will return an empty array, meaning Taproot.jl considers node to be a graph with a singular node (unless you overload this function.)\n\nOverriding this function\n\nSimply define Taproots.children(node::MyType) = ... Where the ... returns a vector of the things you want to traverse.\n\nWhen a connector is supplied\n\nYou can call children([connector::Function,], node)\n\nThe connector is a function which will simply filter the list of children. This need not be overridden\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.data-Tuple{Any}","page":"API","title":"Taproots.data","text":"data(x)\n\nGets the data of a single node in a Taproot DAG (if defined) of x. This function is optional (recommended) to override and can neaten up your life. This function separates the idea of data that a node holds versus the children of your taproot.\n\nBy default, data(x) will return x, meaning Taproots.jl considers x (i.e. the entire node) to be perfectly valid data in and of itself. However, this is sometimes dangerous, because editing x can destroy the link to x's children. Override it to get rid of this danger.\n\nWhatever you define data(x) to be needs to be consistent with `setdata!()\n\nOverriding this function\n\nSimply define Taproots.data(x::MyType) = ... Where the ... returns whatever data is not already included in the Taproots.children function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.eachfield-Tuple{Any}","page":"API","title":"Taproots.eachfield","text":"eachfield(x)\n\nReturns a tuple of the values in each field in a struct. Nice for if you have a known number of children.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.findtrace-Tuple{Function, Any}","page":"API","title":"Taproots.findtrace","text":"findtrace(f, parent)\n\nThis is a slower (~linear) algorithm to find the first value where f returns true. It returns a vector which can be used to index into a nested data struct. You can index into your nested data structure using pluck.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.findtraces-Tuple{Function, Any}","page":"API","title":"Taproots.findtraces","text":"findtraces(f, parent)\n\nThis is a slower (~linear) algorithm to find all values where f returns true. It returns a vector which can be used to index into a nested data struct. You can index into your nested data structure using pluck.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.getatkeys-Tuple{Any, Vector}","page":"API","title":"Taproots.getatkeys","text":"getatkeys(indexable_struct, trace, default_value)\n\nThis is just a convenience function to index into a nest object (potentially not a taproot in any way) by some iterable value of keys.\n\nExample\n\ndict = Dict(1 => Dict(:a => Dict(1 => Dict(:a => \"Finally here\"))))\n\ngetatkeys(dict, (1,:a,1,:a)) == \"Finally here\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.graft!-Tuple{Any, AbstractVector, Any}","page":"API","title":"Taproots.graft!","text":"graft!(parent, trace, value)\n\nThis sets the node which matches a trace. A trace is simply an iterable set of children indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.isbranch-Tuple{Any}","page":"API","title":"Taproots.isbranch","text":"isbranch(node)::Bool\n\nTells you whether this node is a branch node (i.e. it has children).\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.ischild-Tuple{Any, Any}","page":"API","title":"Taproots.ischild","text":"ischild(potential_child, parent)::Bool\n\nTells you whether potential_child is a child of parent. This function acts recursively and is not the same as doing potential_child âˆˆ children(parent). Time complexity of this is ~linear in the number of edges in your DAG underneath the parent, so use with care for large DAGs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.isleaf-Tuple{Any}","page":"API","title":"Taproots.isleaf","text":"isleaf(node)::Bool\n\nTells you whether this node is a leaf node (i.e. it has no children).\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.isparent-Tuple{Any, Any}","page":"API","title":"Taproots.isparent","text":"isparent(potential_parent, child)::Bool\n\nTells you whether potential_parent is a parent of child. This function acts recursively. Time complexity of this is ~linear in the number of edges in your DAG underneath the potential_parent, so use with care for large DAGs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leafmap!-Tuple{Function, Any}","page":"API","title":"Taproots.leafmap!","text":"leafmap!(f::Function, taproot)\n\nModify the leaves of a taproot in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leafmap-Tuple{Function, Any}","page":"API","title":"Taproots.leafmap","text":"leafmap(f::Function, taproot)\n\nDeepcopy a taproot and then modify its leaves in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leafprune!-Tuple{Function, Any}","page":"API","title":"Taproots.leafprune!","text":"leafprune!(f::Function, taproot)\n\nThis removes any leaves of the taproot who do not satisfy the criteria given by f in place. f evaluating to true will keep that leaf. This is similar to filter. However, you cannot prune the root of a taproot.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leafprune-Tuple{Function, Any}","page":"API","title":"Taproots.leafprune","text":"prune(f::Function, taproot)\n\nThis deepcopies the taproot and then removes any leaves who do not satisfy the criteria given by f in place. f evaluating to true will keep that leaf. This is similar to filter. However, you cannot prune the root of a taproot.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.leaves-Tuple{Any}","page":"API","title":"Taproots.leaves","text":"leaves(x)\n\nThis creates a lazy iterator for the leaves (those nodes which have no children) of your custom Taproot.\n\nUsage\n\nfor x in leaves(x)     print(x) end\n\ncollect(leaves(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.pluck-Tuple{Any, AbstractVector}","page":"API","title":"Taproots.pluck","text":"pluck(parent, trace[, default = nothing])\n\nThis gets the node which matches a trace. A trace is simply an iterable set of children indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.postorder-Tuple{Any}","page":"API","title":"Taproots.postorder","text":"postorder(x)\n\nThis creates a lazy iterator as a postorder depth-first search of your custom Taproot. In this iterator, children are always iterated on before their parents. Parents will immediately follow their children (so some (possibly irrelevant) children may not be iterated before the parent above them).\n\nUsage\n\nfor x in postorder(x)     print(x) end\n\ncollect(postorder(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.preorder-Tuple{Any}","page":"API","title":"Taproots.preorder","text":"preorder(x)\n\nThis creates a lazy iterator as a preorder depth-first search of your custom Taproot. In this iterator, parents are always iterated on before their children. Unlike usual preorder depth-first search, this one will iterate on rightmost children first before doing leftmost children.\n\nUsage\n\nfor x in preorder(x)     print(x) end\n\ncollect(preorder(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.prune!-Tuple{Function, Any}","page":"API","title":"Taproots.prune!","text":"prune!(f::Function, taproot)\n\nThis removes any children who do not satisfy the criteria given by f in place. f evaluating to true will keep that child. This is similar to filter. However, you cannot prune the root of a taproot.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.prune-Tuple{Function, Any}","page":"API","title":"Taproots.prune","text":"prune(f::Function, taproot)\n\nThis deepcopies the taproot and then removes any children who do not satisfy the criteria given by f in place. f evaluating to true will keep that child. This is similar to filter. However, you cannot prune the root of a taproot.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.setatkeys!-Tuple{Any, Any, Any}","page":"API","title":"Taproots.setatkeys!","text":"setatkeys!(indexable_struct, trace, value)\n\nThis is just a convenience function to index into a nest object (potentially not a taproot in any way) by some iterable value of keys.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.setchildren!-Tuple{Any, Vector}","page":"API","title":"Taproots.setchildren!","text":"setchildren!(node, children::Vector)::typeof(node)\n\nSets the children of your node. This is required for the following functionality:\n\nprune! (and prune variants)\ntapmap! (and tapmap variants)\ngraft!\nuproot\n\nShould return the entire node once completed.\n\nYou will need to define this in such a way that the following should do nothing:\n\nsetchildren!(node, children(node))\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.setdata!-Tuple{Any, Any}","page":"API","title":"Taproots.setdata!","text":"setdata!(node, data)::typeof(node)\n\nSets the data of your node. Useful if you want to be able to tapmap! your taproot without messing up your children.\n\nYou need to keep this consistent with whatever you defined for Taproots.data. In other words, it should be the case that the following does nothing. setdata!(node, data(node))\n\nIt MUST return the entire node once done (and is allowed to simply return data without modifying the node in place).\n\nThis is required to be implemented for the following functionality:\n\ntapmap! (and tapmap and variants)\ngraft!\n\nExample\n\nTaproots.setdata!(node::MyDataStructure, data) = (node.data = data; node)\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapin-Tuple{Any}","page":"API","title":"Taproots.tapin","text":"tapin(node)\n\nThe standard way to access the recursive Taproot constructor. Requires Taproots.data and Taproots.children to work.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapmap!-Tuple{Function, Any}","page":"API","title":"Taproots.tapmap!","text":"tapmap!(f::Function, taproot)\n\nModify all the data of every node in a taproot in place. f only acts on the data in each node. This can handle mutable and immutable trees.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapmap-Tuple{Function, Any}","page":"API","title":"Taproots.tapmap","text":"tapmap(f::Function, taproot)\n\nDeepcopy a taproot and then modify its nodes in place. f only acts on the data in each node. This can handle mutable and immutable trees.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapmapif!-Tuple{Function, Function, Any}","page":"API","title":"Taproots.tapmapif!","text":"tapmapif!(condition::Function, f::Function, taproot)\n\nModifies nodes in place if the entire node satisfies condition. f only acts on the data in each node. This can handle mutable and immutable trees.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapmapif-Tuple{Function, Function, Any}","page":"API","title":"Taproots.tapmapif","text":"tapmapif(condition::Function, f::Function, taproot)\n\nDeepcopy a taproot and then modify its nodes in place if they satisfy condition. f only acts on the data in each node. This can handle mutable and immutable trees.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tapout-Tuple{Function, Taproot}","page":"API","title":"Taproots.tapout","text":"tapout(sink::Function, taproot::Taproot)\n\nThis allows you to transform a Taproots.Taproot struct back into one of your own structs. The sink function needs to be able to transform a single node of a Taproot into a node in your struct. The sink follows the following structure:     sink(data, children) which returns whatever type you want.\n\nAs a simple example, let's say we have\n\nstruct YourType\n    printable_name::String\n    id::UUID\n    data\n    children::Vector{YourType}\nend\nTaproots.children(x::YourType) = x.children\nTaproots.data(x::YourType) = (x.printable_name, x.id, x.data)\n\nThen you can convert that to a Taproots.Taproot as follows:\n\nyour_type = ... # nest your stuff here as much as you want.\nyour_taproot = tapin(your_type)\nyour_modified_type = tapout((data, children) -> YourType(data.printable_name, data.id, data.data, children), modified_taproot)\n\nIn case you have multiple types in your struct chain, you should take that into account in your sink. For example, you can do different things in case your Taproot has String type leaves.\n\nfunction sink(data, children)\n    if data isa String\n        return data\n    else\n        return YourType(data.printable_name, data.id, data.data, children)\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.topdown-Tuple{Any}","page":"API","title":"Taproots.topdown","text":"topdown(x)\n\nThis creates a lazy iterator as a topdown (level-order) breadth-first search of your custom Taproot. The top parents are iterated first, and then the next level down, and so on. All parents are guaranteed to be iterated on before the leaves.\n\nUsage\n\nfor x in topdown(x)     print(x) end\n\ncollect(topdown(x)) <: Vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.tracepairs-Tuple{Any}","page":"API","title":"Taproots.tracepairs","text":"tracepairs(x)\n\nThis creates a lazy iterator for all the traces and nodes of a taproot. This will always be in the preorder (depth-first search).\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.traces-Tuple{Any}","page":"API","title":"Taproots.traces","text":"traces(x)\n\nThis creates a lazy iterator for all the traces (vectors of indices) needed to get from the root to one of the children. This will always be in the preorder (depth-first search).\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.uproot-Tuple{Any, Any}","page":"API","title":"Taproots.uproot","text":"uproot(parent, child)\n\nGets a child in a taproot, and slices it and all parents out of the taproot, then reverses directions of all the arrows. This is the only way to reverse arrows in Taproots.jl. This can be a bit slow for the moment for large taproots.\n\n\n\n\n\n","category":"method"},{"location":"api/#Taproots.@sprout-Tuple{Any}","page":"API","title":"Taproots.@sprout","text":"@sprout YourType\n\nThis just sets AbstractTrees.children(x::YourType) = Taproots.children(x::YourType). Must be used before you can bloom or @bloom.\n\n\n\n\n\n","category":"macro"},{"location":"#Taproots.jl","page":"Index","title":"Taproots.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This library helps you traverse nested structs and data (including your own custom ones) in easy peasy ways!  This library is inspired by AbstractTrees.jl and provides abstract interface. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"For the purposes of this package, we'll consider any struct a taproot if:","category":"page"},{"location":"","page":"Index","title":"Index","text":"It has nested data which can be accessed from the struct in some way (whether by using keys or by actually holding that data)\nThat nested data forms a Directed Acyclic Graph (DAG) (although this package can handle cycles)\n\"Distance\" between nodes is not something we need to consider (unless it can be held in data of some kind).","category":"page"},{"location":"","page":"Index","title":"Index","text":"That's right, no need to use some struct I created. You can use your own and traverse it a bunch of ways (safe from stack overflow!). ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Worth a quick note that a Taproot is not quite as general as a DAG â€“ with the main difference being that a Taproot has only one root node, and all other nodes eventually point inwards to that root node. Obviously DAGs can also have a distance between nodes â€“ but we're not interested in that. We're only interested to see if a node can or cannot be reached by another one. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"That being said, many structures in the world form Taproots:","category":"page"},{"location":"","page":"Index","title":"Index","text":"File and folder structures (pls ignore symlinks)\nNested data structures such as JSON, YAML, and so on. Nested Julia Dicts also do this.\nA response variable with all its causally-related covariates. ","category":"page"},{"location":"#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"In the Julia REPL, type ] and the add Taproots.","category":"page"},{"location":"#How-to-use","page":"Index","title":"How to use","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"You can turn your own structs into Taproots very quickly!","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Taproots\n\nmutable struct MyType \n\tsome_data\n\tchildren\nend\n\nTaproots.children(x::MyType) = x.children ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Notice that Taproots.children is a function and as such there's no requirement that you're storing the children (like the example above does). You can look it up from a key or from an upvalue. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"We're done! You now have access to (almost) all the functionality in Taproots.jl. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Also worth noting: your struct doesn't need to be mutable. However, it'll simplify things for this example a bit later on. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Now let's say you create some nastily nested structure: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"my_data = MyType(\"The Root\", [\n\tMyType(\"Some other data\", []),\n\tMyType(\"I can nest data here\", [\n\t\tMyType(\"Such nested, much wow\", [])\n\t]),\n\t\"I don't even need to stick to one type ... but obviously a string has no children\",\n\tDict(\n\t\t:x => \"Taproots.children is already implemented on dicts\",\n\t\t:y => :(\"As well as \" * \" other types\")\n\t)\n])","category":"page"},{"location":"","page":"Index","title":"Index","text":"Now you might wish to traverse ALL that data in a lazy, speedy way:","category":"page"},{"location":"","page":"Index","title":"Index","text":"for nested_data in postorder(my_data)\n\tprintln(nested_data)\nend","category":"page"},{"location":"","page":"Index","title":"Index","text":"Or just the things at the edges (which is what I care about most of the time):","category":"page"},{"location":"","page":"Index","title":"Index","text":"for nested_data in leaves(my_data)\n\tprintln(nested_data)\nend","category":"page"},{"location":"","page":"Index","title":"Index","text":"Similar other options exist as well:","category":"page"},{"location":"","page":"Index","title":"Index","text":"preorder(my_data) # a preorder depth-first search \npostorder(my_data) # this is postorder depth-first search\ntopdown(my_data) # a level-order, top-down, breadth-first search\nbottomup(my_data) # a level-order, bottom-up, breadth-first search (a valid topological sort)\n\nleaves(my_data) # only look at the data that doesn't have children\nbranches(my_data) # only look at the data that does have children\n\ntraces(my_data) # get all traces (trace = a simple vector of indices in order) so that you can index into a particular child later\ntracepairs(my_data) # get all traces along with nodes themselves","category":"page"},{"location":"","page":"Index","title":"Index","text":"Each of those functions returns a Julia Channel, so you can use it like any iterator, using map, reduce, and Iterators.filter. Obviously you can just collect that into a vector if you prefer (and you don't need the laziness benefits).","category":"page"},{"location":"","page":"Index","title":"Index","text":"my_data_in_a_vec = my_data |> postorder |> collect\nprintln(my_data_in_a_vec)\n\n\nIterators.filter(x -> x isa String, leaves(my_data)) |> first # gives us the only string in the data structure ... \"I don't even need to stick to one type ... but obviously a string has no children\"","category":"page"},{"location":"","page":"Index","title":"Index","text":"Packages like this one are nice but you may be worried about interoperability with other (potentially more expansive) packages. So to make it all work out plainly, you can grab an adjacency matrix of your taproot whenever you want.","category":"page"},{"location":"","page":"Index","title":"Index","text":"adjacencymatrix(my_data) # gives us an adjacency matrix of 1s and 0s","category":"page"},{"location":"","page":"Index","title":"Index","text":"You are now able to shove the structure of your DAG into another graph-specific utility. But don't be too hasty; check out the cool things Taproots.jl can do first!","category":"page"},{"location":"","page":"Index","title":"Index","text":"There are also other handy functions to help you flag certain nodes so you know what they look like in your structure:","category":"page"},{"location":"","page":"Index","title":"Index","text":"ischild(potential_child, parent) # true if the potential child is recursively a child of the parent. \nisparent(potential_parent, child) # true if the potential parent is recursively a parent of the child. \nisleaf(node) # true if the node has no children\nisbranch(node) # true if the node has any children","category":"page"},{"location":"","page":"Index","title":"Index","text":"There are handy functions to help you find nodes as well! ","category":"page"},{"location":"","page":"Index","title":"Index","text":"findtrace(matcher, my_data) # gets you an index trace of the first node for which matcher(node) evaluates to true. \nfindtrace(child, my_data) # gets you an index trace of the first node which is equal to child. \nfindtraces(matcher, my_data) # gets you every index trace of the nodes for which matcher(node) evaluates to true.\nfindtraces(child, my_data) # gets you every index trace of the nodes for which node == child. \npluck(my_data, trace; default = nothing) # follows the index down to the pits to get you back whatever is in that index spot, otherwise return `default`","category":"page"},{"location":"#Modification-of-data-and-structure","page":"Index","title":"Modification of data and structure","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Now there comes a time in every Taprootian's life when they yearn to modify their Taproots in place. And this is a dangerous topic because if you modify a Taproot in place, you might destroy the links to the children inadvertently. So for this purpose, you would need to add a few more functions. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Taproots.data(node::MyType) = node.some_data # provide a way to get any auxiliary data (other than children) that your node might contain. Can simply return `node` or nothing at all. Doing this will unlock sinking your type to a Taproots.Taproot. \nTaproots.setdata!(node::MyType, data) = (node.some_data = data; node) # provide a way to set data in your node, if any. It can also do nothing. Once done, it must return `node`. This one as well as the next unlocks `tapmap` and variants.\nTaproots.setchildren!(node::MyType, children::Vector) = (node.children = children; node) # provide a way to set children in your node. Once done, it must return `node`. This one unlocks `prune` and variants. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"tip: Tip\nTaproots.data is an easy one to implement, but it's pretty useless unless you also implement the other functions. Taproots.setdata! is also easy to implement â€“ because it doesn't matter if your type is mutable or immutable. You can modify it (and then return the node) if it's mutable. If immutable, just return a newly created node with modified data.Taproots.setchildren! can sometimes be a bit trickier to implement â€“ it requires us to actually mutate the way we get children.Remember that at any stage you can check whether your Taproots.data and Taproots.setdata! work just by calling them on each other. E.g. setdata!(taproot, data(taproot)) needs to look the same as the original taproot.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Now we get the good stuff. We can map every node's data while keeping the structure sparkly. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"tapmap(x -> x isa String ? uppercase(x) : x, my_data) ","category":"page"},{"location":"","page":"Index","title":"Index","text":"This gives us something like this: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"MyType(\"THE ROOT\", [\n\tMyType(\"SOME OTHER DATA\", []),\n\tMyType(\"I CAN NEST DATA HERE\", [\n\t\tMyType(\"SUCH NESTED, MUCH WOW\", [])\n\t]),\n\t\"I DON'T EVEN NEED TO STICK TO ONE TYPE ... BUT OBVIOUSLY A STRING HAS NO CHILDREN\",\n\tDict(\n\t\t:x => \"TAPROOTS.CHILDREN IS ALREADY IMPLEMENTED ON DICTS\",\n\t\t:y => :(\"AS WELL AS \" * \" OTHER TYPES\")\n\t)\n])","category":"page"},{"location":"","page":"Index","title":"Index","text":"warning: Warning\nx comes straight from Taproots.data(node). x itself is not a node, and as such the strings inside MyType also get converted. Very awesome, but be careful! If you prefer changing the entire nodes themselves, then: 1) ensure Taproots.data(node::MyType) = node; or 2) use the regular iterators such as postorder(node) which returns entire nodes.","category":"page"},{"location":"","page":"Index","title":"Index","text":"We can also get rid of all the nodes we don't like (... except the root, topmost node. Prune won't get rid of that one, and for good reason.)","category":"page"},{"location":"","page":"Index","title":"Index","text":"prune(x -> x isa MyType, my_data) # keep only the nodes which are MyTypes","category":"page"},{"location":"","page":"Index","title":"Index","text":"There are similar handy functions such as:","category":"page"},{"location":"","page":"Index","title":"Index","text":"tapmap!(f, taprootius) # modify all nodes in place\ntapmap(f, taprootius) # deepcopy and then modify all nodes in place\n\ntapmapif!(condition, f, taprootius) # modify nodes in place if they satisfy `condition`. Very handy if your tree has multiple different types. \ntapmapif(condition, f, taprootius) # deepcopy and then modify nodes in place if they satisfy `condition`. Very handy if your tree has multiple different types. \n\nleafmap!(f, taprootius) # modify all leaves in place\nleafmap(f, taprootius) # deepcopy and then modify all leaves in place\n\nbranchmap!(f, taprootius) # modify all branches in place\nbranchmap(f, taprootius) # deepcopy and then modify all branches in place\n\nprune!(f, taprootius) # get rid of children which do not satisfy f in place\nprune(f, taprootius) # deepcopy and then get rid of children which do not satisfy f in place\n\nleafprune!(f, taprootius) # get rid of leaves which do not satisfy f in place\nleafprune(f, taprootius) # deepcopy and then get rid of leaves which do not satisfy f in place\n\nbranchprune!(f, taprootius) # get rid of branches which do not satisfy f in place\nbranchprune(f, taprootius) # deepcopy and then get rid of branches which do not satisfy f in place","category":"page"},{"location":"","page":"Index","title":"Index","text":"You also get other handy functions by implementing those functions:","category":"page"},{"location":"","page":"Index","title":"Index","text":"graft!(taproot, trace, node) # Where `pluck` is get, this is set. This sets the trace to `node`. Only grafts that one trace, not other traces (which might lead to the same node)\nuproot!(root, child) # pluck out `child` and ALL its parents. Then reverse the directions of the arrows. This is the only way to reverse arrows in `Taproots.jl`","category":"page"},{"location":"","page":"Index","title":"Index","text":"tip: Tip\nMy suggestion would be to try create a Base.copy implementation for your type if it's not obvious and not simply constructed from a constructor of its fields.  We use Base.copy if it's available when doing all the non-modifying variants of the functions above. ","category":"page"},{"location":"#Built-in-taproots","page":"Index","title":"Built-in taproots","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"It's not the point of this package, but there is a minimal (but fully functional) mutable struct called Taproot which this package exports. You can use this to store data if you couldn't be bothered with nesting things in your own struct. Taproots, however, don't allow arbitrary children types.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Taproot(data::Any, children::Vector{Taproot})","category":"page"},{"location":"","page":"Index","title":"Index","text":"Alternatively, you can convert your type to a Taproots.Taproot. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"taprootius = tapin(my_data)","category":"page"},{"location":"","page":"Index","title":"Index","text":"You can get back out again simply by providing some kind of sink. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"back_to_the_future = tapout((data, children) -> MyType(data, children), taprootius)","category":"page"},{"location":"","page":"Index","title":"Index","text":"In the example above, the children will automatically be coverted to MyType because the sink function we provided gets called recursively. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Taproots.jl also treats many base types like Dict, Vector, and Expr as taproots, and all other types as leaves. So you can do something like this ","category":"page"},{"location":"","page":"Index","title":"Index","text":"dict = Dict(\n\t\t:a => Dict(\n\t\t\t:b => \"nonsense_data\",\n\t\t\t:c => \"more_data\",\n\t\t),\n\t\t:d => \"final_data\"\n\t)\nleafmap!(uppercase, dict)","category":"page"},{"location":"","page":"Index","title":"Index","text":"Here's another usecase: metaprogramming. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"nums = 1:100\nexpr = :(append!(map(x -> sqrt(x) == floor(sqrt(x)), nums), map(x -> x^(1/3) == floor(x^(1/3)), nums)) |> unique!)\nleafmap!(x -> x == :map ? :filter : x, expr)\neval(expr)","category":"page"},{"location":"","page":"Index","title":"Index","text":"This last bit here is absolute raw power. Code expressions are abstract syntax trees, and so they are taproots as well.","category":"page"},{"location":"","page":"Index","title":"Index","text":"You might be wondering at this stage, \"Is every struct actually a taproot\". Of course they are ... ","category":"page"},{"location":"","page":"Index","title":"Index","text":"struct FourLeggedStruct \n\ta\n\tb\n\tc\n\td\nend ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Can we just define the children to be (a,b,c,d)? Yes, we can, and it's easy. But sometimes it's better not to think of them that way, and that's why this isn't the default behaviour of Taproots.jl. But should you want to, you can just do this ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Taproots.children(x::FourLeggedStruct) = eachfield(x)","category":"page"},{"location":"","page":"Index","title":"Index","text":"Or if you just want to traverse a ton of stuff:","category":"page"},{"location":"","page":"Index","title":"Index","text":"Taproots.children(x) = eachfield(x) # now everything will do this by default (unless more specifically defined). ","category":"page"},{"location":"","page":"Index","title":"Index","text":"There is also one more thing this package does which I think it pretty handy and which is related to the main concepts that Taproot deals with, but does not actually a require a taproot. It requires nested data with keys. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"dict = Dict(1 => Dict(:a => Dict(1 => Dict(:a => \"Finally here\"))))\ngetatkeys(dict, (1,:a,1,:a)) == \"Finally here\"\nsetatkeys!(dict, (1,:a,1,:a), \"Not finally here anymore!\")","category":"page"},{"location":"#Seeing-the-structure-of-your-DAGs","page":"Index","title":"Seeing the structure of your DAGs","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This package is interoperable with Term.jl for a CLI view and adds two very nice graph recipes to Plots.jl.   The data inside these can get cluttered, so it's recommended that you just overload Base.show for your custom types.","category":"page"},{"location":"#Terminal-visualisation","page":"Index","title":"Terminal visualisation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"@sprout MyType # sets up AbstractTrees.jl and Term.jl so that you can call bloom if you want\n@bloom my_data # shows the data nicely","category":"page"},{"location":"#Plotting","page":"Index","title":"Plotting","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"using Plots\n\nplotdag(my_data)\nplottree(my_data)","category":"page"},{"location":"#FAQ","page":"Index","title":"FAQ","text":"","category":"section"},{"location":"#Why-do-I-need-to-define-children-and-data-and-setchildren!-and-setdata!.-Why-not-just-children-and-setchildren!?","page":"Index","title":"Why do I need to define children and data and setchildren! and setdata!. Why not just children and setchildren!?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"So that you don't accidentally lose the children by calling tapmap!, and you don't accidentally modify data with prune!.","category":"page"},{"location":"#How-can-I-improve-the-speed-of-tapmap!-(and-similar)?","page":"Index","title":"How can I improve the speed of tapmap! (and similar)?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Use tapmapif!(condition, f, taproot). This will only execute f and set data and so on if the condition is satisfied. ","category":"page"},{"location":"#What-if-my-struct-is-immutable?","page":"Index","title":"What if my struct is immutable?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"If your Taproots.data is immutable, that's fine. You just need Taproots.setdata! to return the entire node (as always). I catered for that in tapmap! because this is so common with leaf nodes.  tapmap! will automatically reconstruct the children in a nice way for you â€“ but, warning, it calls Taproots.setchildren!.  If your children are immutable, I haven't catered for that nicely, and neither tapmap! nor prune! (and variants) will work. ","category":"page"},{"location":"#How-do-I-do-this-kind-of-thing-for-my-filesystem?","page":"Index","title":"How do I do this kind of thing for my filesystem?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"You can find every single file (recursively) in a folder very quickly! Handy for including files.","category":"page"},{"location":"","page":"Index","title":"Index","text":"using FilePathsBase\n\np = p\"path/to/folder\"\nTaproots.children(path::AbstractPath) = isdir(path) ? joinpath.(path, readdir(path)) : []\nleaves(p) .|> println","category":"page"}]
}
