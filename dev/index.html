<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · Taproots</title><meta name="title" content="Index · Taproots"/><meta property="og:title" content="Index · Taproots"/><meta property="twitter:title" content="Index · Taproots"/><meta name="description" content="Documentation for Taproots."/><meta property="og:description" content="Documentation for Taproots."/><meta property="twitter:description" content="Documentation for Taproots."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Taproots</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#How-to-use"><span>How to use</span></a></li><li><a class="tocitem" href="#Modification-of-data-and-structure"><span>Modification of data and structure</span></a></li><li><a class="tocitem" href="#Built-in-taproots"><span>Built-in taproots</span></a></li><li><a class="tocitem" href="#Seeing-the-structure-of-your-DAGs"><span>Seeing the structure of your DAGs</span></a></li><li><a class="tocitem" href="#FAQ"><span>FAQ</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TyronCameron/Taproots.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TyronCameron/Taproots.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Taproots.jl"><a class="docs-heading-anchor" href="#Taproots.jl">Taproots.jl</a><a id="Taproots.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Taproots.jl" title="Permalink"></a></h1><p>This library helps you traverse nested structs and data (including your own custom ones) in easy peasy ways!  This library is inspired by <code>AbstractTrees.jl</code> and provides abstract interface. </p><p>For the purposes of this package, we&#39;ll consider <em>any</em> struct a taproot if:</p><ul><li>It has nested data which can be accessed from the struct in some way (whether by using keys or by actually holding that data)</li><li>That nested data forms a Directed Acyclic Graph (DAG) (although this package can handle cycles)</li><li>&quot;Distance&quot; between nodes is not something we need to consider (unless it can be held in data of some kind).</li></ul><p>That&#39;s right, no need to use some struct I created. You can use your own and traverse it a bunch of ways (safe from stack overflow!). </p><p>Worth a quick note that a Taproot is not quite as general as a DAG – with the main difference being that a Taproot has only one root node, and all other nodes eventually point inwards to that root node. Obviously DAGs can also have a distance between nodes – but we&#39;re not interested in that. We&#39;re only interested to see if a node can or cannot be reached by another one. </p><p>That being said, many structures in the world form Taproots:</p><ul><li>File and folder structures (pls ignore symlinks)</li><li>Nested data structures such as JSON, YAML, and so on. Nested Julia Dicts also do this.</li><li>A response variable with all its causally-related covariates. </li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>In the Julia REPL, type ] and the <code>add Taproots</code>.</p><h2 id="How-to-use"><a class="docs-heading-anchor" href="#How-to-use">How to use</a><a id="How-to-use-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use" title="Permalink"></a></h2><p>You can turn your own structs into Taproots very quickly!</p><pre><code class="language-julia hljs">using Taproots

mutable struct MyType 
	some_data
	children
end

Taproots.children(x::MyType) = x.children </code></pre><p>Notice that <code>Taproots.children</code> is a function and as such there&#39;s no requirement that you&#39;re storing the children (like the example above does). You can look it up from a key or from an upvalue. </p><p>We&#39;re done! You now have access to (almost) all the functionality in <code>Taproots.jl</code>. </p><p>Also worth noting: your struct doesn&#39;t need to be mutable. However, it&#39;ll simplify things for this example a bit later on. </p><p>Now let&#39;s say you create some nastily nested structure: </p><pre><code class="language-julia hljs">my_data = MyType(&quot;The Root&quot;, [
	MyType(&quot;Some other data&quot;, []),
	MyType(&quot;I can nest data here&quot;, [
		MyType(&quot;Such nested, much wow&quot;, [])
	]),
	&quot;I don&#39;t even need to stick to one type ... but obviously a string has no children&quot;,
	Dict(
		:x =&gt; &quot;Taproots.children is already implemented on dicts&quot;,
		:y =&gt; :(&quot;As well as &quot; * &quot; other types&quot;)
	)
])</code></pre><p>Now you might wish to traverse ALL that data in a lazy, speedy way:</p><pre><code class="language-julia hljs">for nested_data in postorder(my_data)
	println(nested_data)
end</code></pre><p>Or just the things at the edges (which is what I care about most of the time):</p><pre><code class="language-julia hljs">for nested_data in leaves(my_data)
	println(nested_data)
end</code></pre><p>Similar other options exist as well:</p><pre><code class="language-julia hljs">preorder(my_data) # a preorder depth-first search 
postorder(my_data) # this is postorder depth-first search
topdown(my_data) # a level-order, top-down, breadth-first search
bottomup(my_data) # a level-order, bottom-up, breadth-first search (a valid topological sort)

leaves(my_data) # only look at the data that doesn&#39;t have children
branches(my_data) # only look at the data that does have children

traces(my_data) # get all traces (trace = a simple vector of indices in order) so that you can index into a particular child later
tracepairs(my_data) # get all traces along with nodes themselves</code></pre><p>Each of those functions returns a Julia Channel, so you can use it like any iterator, using <code>map</code>, <code>reduce</code>, and <code>Iterators.filter</code>. Obviously you can just <code>collect</code> that into a vector if you prefer (and you don&#39;t need the laziness benefits).</p><pre><code class="language-julia hljs">my_data_in_a_vec = my_data |&gt; postorder |&gt; collect
println(my_data_in_a_vec)


Iterators.filter(x -&gt; x isa String, leaves(my_data)) |&gt; first # gives us the only string in the data structure ... &quot;I don&#39;t even need to stick to one type ... but obviously a string has no children&quot;</code></pre><p>Packages like this one are nice but you may be worried about interoperability with other (potentially more expansive) packages. So to make it all work out plainly, you can grab an adjacency matrix of your taproot whenever you want.</p><pre><code class="language-julia hljs">adjacencymatrix(my_data) # gives us an adjacency matrix of 1s and 0s</code></pre><p>You are now able to shove the structure of your DAG into another graph-specific utility. But don&#39;t be too hasty; check out the cool things <code>Taproots.jl</code> can do first!</p><p>There are also other handy functions to help you flag certain nodes so you know what they look like in your structure:</p><pre><code class="language-julia hljs">ischild(potential_child, parent) # true if the potential child is recursively a child of the parent. 
isparent(potential_parent, child) # true if the potential parent is recursively a parent of the child. 
isleaf(node) # true if the node has no children
isbranch(node) # true if the node has any children</code></pre><p>There are handy functions to help you find nodes as well! </p><pre><code class="language-julia hljs">findtrace(matcher, my_data) # gets you an index trace of the first node for which matcher(node) evaluates to true. 
findtrace(child, my_data) # gets you an index trace of the first node which is equal to child. 
findtraces(matcher, my_data) # gets you every index trace of the nodes for which matcher(node) evaluates to true.
findtraces(child, my_data) # gets you every index trace of the nodes for which node == child. 
pluck(my_data, trace; default = nothing) # follows the index down to the pits to get you back whatever is in that index spot, otherwise return `default`</code></pre><h2 id="Modification-of-data-and-structure"><a class="docs-heading-anchor" href="#Modification-of-data-and-structure">Modification of data and structure</a><a id="Modification-of-data-and-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Modification-of-data-and-structure" title="Permalink"></a></h2><p>Now there comes a time in every Taprootian&#39;s life when they yearn to modify their Taproots in place. And this is a dangerous topic because if you modify a Taproot in place, you might destroy the links to the children inadvertently. So for this purpose, you would need to add a few more functions. </p><pre><code class="language-julia hljs">Taproots.data(node::MyType) = node.some_data # provide a way to get any auxiliary data (other than children) that your node might contain. Can simply return `node` or nothing at all. Doing this will unlock sinking your type to a Taproots.Taproot. 
Taproots.setdata!(node::MyType, data) = (node.some_data = data; node) # provide a way to set data in your node, if any. It can also do nothing. Once done, it must return `node`. This one as well as the next unlocks `tapmap` and variants.
Taproots.setchildren!(node::MyType, children::Vector) = (node.children = children; node) # provide a way to set children in your node. Once done, it must return `node`. This one unlocks `prune` and variants. </code></pre><div class="admonition is-success" id="Tip-964984f055c1bd70"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-964984f055c1bd70" title="Permalink"></a></header><div class="admonition-body"><p><code>Taproots.data</code> is an easy one to implement, but it&#39;s pretty useless unless you also implement the other functions. </p><p><code>Taproots.setdata!</code> is also easy to implement – because it doesn&#39;t matter if your type is mutable or immutable. You can modify it (and then return the node) if it&#39;s mutable. If immutable, just return a newly created node with modified data.</p><p><code>Taproots.setchildren!</code> can sometimes be a bit trickier to implement – it requires us to actually mutate the way we get children.</p><p>Remember that at any stage you can check whether your <code>Taproots.data</code> and <code>Taproots.setdata!</code> work just by calling them on each other. E.g. <code>setdata!(taproot, data(taproot))</code> needs to look the same as the original <code>taproot</code>.</p></div></div><p>Now we get the <em>good</em> stuff. We can map every node&#39;s data while keeping the structure sparkly. </p><pre><code class="language-julia hljs">tapmap(x -&gt; x isa String ? uppercase(x) : x, my_data) </code></pre><p>This gives us something like this: </p><pre><code class="language-julia hljs">MyType(&quot;THE ROOT&quot;, [
	MyType(&quot;SOME OTHER DATA&quot;, []),
	MyType(&quot;I CAN NEST DATA HERE&quot;, [
		MyType(&quot;SUCH NESTED, MUCH WOW&quot;, [])
	]),
	&quot;I DON&#39;T EVEN NEED TO STICK TO ONE TYPE ... BUT OBVIOUSLY A STRING HAS NO CHILDREN&quot;,
	Dict(
		:x =&gt; &quot;TAPROOTS.CHILDREN IS ALREADY IMPLEMENTED ON DICTS&quot;,
		:y =&gt; :(&quot;AS WELL AS &quot; * &quot; OTHER TYPES&quot;)
	)
])</code></pre><div class="admonition is-warning" id="Warning-e65b7bf1201161c1"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-e65b7bf1201161c1" title="Permalink"></a></header><div class="admonition-body"><p><code>x</code> comes straight from <code>Taproots.data(node)</code>. <code>x</code> itself is not a node, and as such the strings inside <code>MyType</code> also get converted. Very awesome, but be careful! If you prefer changing the entire nodes themselves, then: 1) ensure <code>Taproots.data(node::MyType) = node</code>; or 2) use the regular iterators such as <code>postorder(node)</code> which returns entire nodes.</p></div></div><p>We can also get rid of all the nodes we don&#39;t like (... except the root, topmost node. Prune won&#39;t get rid of that one, and for good reason.)</p><pre><code class="language-julia hljs">prune(x -&gt; x isa MyType, my_data) # keep only the nodes which are MyTypes</code></pre><p>There are similar handy functions such as:</p><pre><code class="language-julia hljs">tapmap!(f, taprootius) # modify all nodes in place
tapmap(f, taprootius) # deepcopy and then modify all nodes in place

tapmapif!(condition, f, taprootius) # modify nodes in place if they satisfy `condition`. Very handy if your tree has multiple different types. 
tapmapif(condition, f, taprootius) # deepcopy and then modify nodes in place if they satisfy `condition`. Very handy if your tree has multiple different types. 

leafmap!(f, taprootius) # modify all leaves in place
leafmap(f, taprootius) # deepcopy and then modify all leaves in place

branchmap!(f, taprootius) # modify all branches in place
branchmap(f, taprootius) # deepcopy and then modify all branches in place

prune!(f, taprootius) # get rid of children which do not satisfy f in place
prune(f, taprootius) # deepcopy and then get rid of children which do not satisfy f in place

leafprune!(f, taprootius) # get rid of leaves which do not satisfy f in place
leafprune(f, taprootius) # deepcopy and then get rid of leaves which do not satisfy f in place

branchprune!(f, taprootius) # get rid of branches which do not satisfy f in place
branchprune(f, taprootius) # deepcopy and then get rid of branches which do not satisfy f in place</code></pre><p>You also get other handy functions by implementing those functions:</p><pre><code class="language-julia hljs">graft!(taproot, trace, node) # Where `pluck` is get, this is set. This sets the trace to `node`. Only grafts that one trace, not other traces (which might lead to the same node)
uproot!(root, child) # pluck out `child` and ALL its parents. Then reverse the directions of the arrows. This is the only way to reverse arrows in `Taproots.jl`</code></pre><div class="admonition is-success" id="Tip-8034fb8ae5b435ce"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-8034fb8ae5b435ce" title="Permalink"></a></header><div class="admonition-body"><p>My suggestion would be to try create a <code>Base.copy</code> implementation for your type if it&#39;s not obvious and not simply constructed from a constructor of its fields.  We use <code>Base.copy</code> if it&#39;s available when doing all the non-modifying variants of the functions above. </p></div></div><h2 id="Built-in-taproots"><a class="docs-heading-anchor" href="#Built-in-taproots">Built-in taproots</a><a id="Built-in-taproots-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-taproots" title="Permalink"></a></h2><p>It&#39;s not the point of this package, but there is a minimal (but fully functional) mutable struct called Taproot which this package exports. You can use this to store data if you couldn&#39;t be bothered with nesting things in your own struct. Taproots, however, don&#39;t allow arbitrary children types.</p><pre><code class="language-julia hljs">Taproot(data::Any, children::Vector{Taproot})</code></pre><p>Alternatively, you can convert your type to a Taproots.Taproot. </p><pre><code class="language-julia hljs">taprootius = tapin(my_data)</code></pre><p>You can get back out again simply by providing some kind of sink. </p><pre><code class="language-julia hljs">back_to_the_future = tapout((data, children) -&gt; MyType(data, children), taprootius)</code></pre><p>In the example above, the children will automatically be coverted to <code>MyType</code> because the <code>sink</code> function we provided gets called recursively. </p><p>Taproots.jl also treats many base types like <code>Dict</code>, <code>Vector</code>, and <code>Expr</code> as taproots, and all other types as leaves. So you can do something like this </p><pre><code class="language-julia hljs">dict = Dict(
		:a =&gt; Dict(
			:b =&gt; &quot;nonsense_data&quot;,
			:c =&gt; &quot;more_data&quot;,
		),
		:d =&gt; &quot;final_data&quot;
	)
leafmap!(uppercase, dict)</code></pre><p>Here&#39;s another usecase: metaprogramming. </p><pre><code class="language-julia hljs">nums = 1:100
expr = :(append!(map(x -&gt; sqrt(x) == floor(sqrt(x)), nums), map(x -&gt; x^(1/3) == floor(x^(1/3)), nums)) |&gt; unique!)
leafmap!(x -&gt; x == :map ? :filter : x, expr)
eval(expr)</code></pre><p>This last bit here is absolute raw power. Code expressions are abstract syntax trees, and so they are taproots as well.</p><p>You might be wondering at this stage, &quot;Is every struct actually a taproot&quot;. Of course they are ... </p><pre><code class="language-julia hljs">struct FourLeggedStruct 
	a
	b
	c
	d
end </code></pre><p>Can we just define the children to be <code>(a,b,c,d)</code>? Yes, we can, and it&#39;s easy. But sometimes it&#39;s better not to think of them that way, and that&#39;s why this isn&#39;t the default behaviour of Taproots.jl. But should you want to, you can just do this </p><pre><code class="language-julia hljs">Taproots.children(x::FourLeggedStruct) = eachfield(x)</code></pre><p>Or if you just want to traverse a ton of stuff:</p><pre><code class="language-julia hljs">Taproots.children(x) = eachfield(x) # now everything will do this by default (unless more specifically defined). </code></pre><p>There is also one more thing this package does which I think it pretty handy and which is related to the main concepts that Taproot deals with, but does not actually a require a taproot. It requires nested data with keys. </p><pre><code class="language-julia hljs">dict = Dict(1 =&gt; Dict(:a =&gt; Dict(1 =&gt; Dict(:a =&gt; &quot;Finally here&quot;))))
getatkeys(dict, (1,:a,1,:a)) == &quot;Finally here&quot;
setatkeys!(dict, (1,:a,1,:a), &quot;Not finally here anymore!&quot;)</code></pre><h2 id="Seeing-the-structure-of-your-DAGs"><a class="docs-heading-anchor" href="#Seeing-the-structure-of-your-DAGs">Seeing the structure of your DAGs</a><a id="Seeing-the-structure-of-your-DAGs-1"></a><a class="docs-heading-anchor-permalink" href="#Seeing-the-structure-of-your-DAGs" title="Permalink"></a></h2><p>This package is interoperable with Term.jl for a CLI view and adds two very nice graph recipes to Plots.jl.   The data inside these can get cluttered, so it&#39;s recommended that you just overload <code>Base.show</code> for your custom types.</p><h3 id="Terminal-visualisation"><a class="docs-heading-anchor" href="#Terminal-visualisation">Terminal visualisation</a><a id="Terminal-visualisation-1"></a><a class="docs-heading-anchor-permalink" href="#Terminal-visualisation" title="Permalink"></a></h3><pre><code class="language-julia hljs">@sprout MyType # sets up AbstractTrees.jl and Term.jl so that you can call bloom if you want
@bloom my_data # shows the data nicely</code></pre><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Plots

plotdag(my_data)
plottree(my_data)</code></pre><h2 id="FAQ"><a class="docs-heading-anchor" href="#FAQ">FAQ</a><a id="FAQ-1"></a><a class="docs-heading-anchor-permalink" href="#FAQ" title="Permalink"></a></h2><h3 id="Why-do-I-need-to-define-children-and-data-and-setchildren!-and-setdata!.-Why-not-just-children-and-setchildren!?"><a class="docs-heading-anchor" href="#Why-do-I-need-to-define-children-and-data-and-setchildren!-and-setdata!.-Why-not-just-children-and-setchildren!?">Why do I need to define <code>children</code> and <code>data</code> and <code>setchildren!</code> and <code>setdata!</code>. Why not just <code>children</code> and <code>setchildren!</code>?</a><a id="Why-do-I-need-to-define-children-and-data-and-setchildren!-and-setdata!.-Why-not-just-children-and-setchildren!?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-do-I-need-to-define-children-and-data-and-setchildren!-and-setdata!.-Why-not-just-children-and-setchildren!?" title="Permalink"></a></h3><p>So that you don&#39;t accidentally lose the children by calling <code>tapmap!</code>, and you don&#39;t accidentally modify data with <code>prune!</code>.</p><h3 id="How-can-I-improve-the-speed-of-tapmap!-(and-similar)?"><a class="docs-heading-anchor" href="#How-can-I-improve-the-speed-of-tapmap!-(and-similar)?">How can I improve the speed of <code>tapmap!</code> (and similar)?</a><a id="How-can-I-improve-the-speed-of-tapmap!-(and-similar)?-1"></a><a class="docs-heading-anchor-permalink" href="#How-can-I-improve-the-speed-of-tapmap!-(and-similar)?" title="Permalink"></a></h3><p>Use <code>tapmapif!(condition, f, taproot)</code>. This will only execute <code>f</code> and set data and so on if the condition is satisfied. </p><h3 id="What-if-my-struct-is-immutable?"><a class="docs-heading-anchor" href="#What-if-my-struct-is-immutable?">What if my struct is immutable?</a><a id="What-if-my-struct-is-immutable?-1"></a><a class="docs-heading-anchor-permalink" href="#What-if-my-struct-is-immutable?" title="Permalink"></a></h3><p>If your <code>Taproots.data</code> is immutable, that&#39;s fine. You just need <code>Taproots.setdata!</code> to return the entire node (as always). I catered for that in <code>tapmap!</code> because this is so common with leaf nodes.  <code>tapmap!</code> will automatically reconstruct the children in a nice way for you – but, warning, it calls <code>Taproots.setchildren!</code>.  If your children are immutable, I haven&#39;t catered for that nicely, and neither <code>tapmap!</code> nor <code>prune!</code> (and variants) will work. </p><h3 id="How-do-I-do-this-kind-of-thing-for-my-filesystem?"><a class="docs-heading-anchor" href="#How-do-I-do-this-kind-of-thing-for-my-filesystem?">How do I do this kind of thing for my filesystem?</a><a id="How-do-I-do-this-kind-of-thing-for-my-filesystem?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-do-this-kind-of-thing-for-my-filesystem?" title="Permalink"></a></h3><p>You can find every single file (recursively) in a folder very quickly! Handy for including files.</p><pre><code class="language-julia hljs">using FilePathsBase

p = p&quot;path/to/folder&quot;
Taproots.children(path::AbstractPath) = isdir(path) ? joinpath.(path, readdir(path)) : []
leaves(p) .|&gt; println</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 27 December 2025 08:19">Saturday 27 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
